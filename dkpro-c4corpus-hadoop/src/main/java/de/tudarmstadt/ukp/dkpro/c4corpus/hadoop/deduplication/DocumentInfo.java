/*
 * Copyright 2016
 * Ubiquitous Knowledge Processing (UKP) Lab
 * Technische Universit√§t Darmstadt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.tudarmstadt.ukp.dkpro.c4corpus.hadoop.deduplication;

import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import org.apache.hadoop.io.WritableComparable;

/**
 * A custom Writable implementation for document information.
 *
 * @author Omnia Zayed
 *
 */
public class DocumentInfo
        implements WritableComparable<DocumentInfo> {

    private Text docID;
    private IntWritable docLength;
    private LongWritable docSimHash;
    private Text language;
    private Text license;
    private Text noBoilerplate;
    private Text minimalHtml;

    /**
     * Private constructor since we're just a data object, we want to be initialized.
     */
    private DocumentInfo() {
    }

    /**
     * Construct a new DocumentInfo object with the given attributes
     * 
     * @param docID id for document
     * @param length length in bytes
     * @param hash SimHash value for document
     * @param lang language
     */
    public DocumentInfo(String docID, int length, long hash, String lang, String license, String noBoilerplate,
            String html)
    {
        this.docID = new Text(docID);
        this.docLength = new IntWritable(length);
        this.docSimHash = new LongWritable(hash);
        if (lang == null) {
            lang = "unknown";
        }
        this.language = new Text(lang);
        if (license == null) {
            license = "none";
        }
        this.license = new Text(license);
        this.noBoilerplate = new Text(noBoilerplate);
        this.minimalHtml = new Text(html);
    }

    public DocumentInfo(Text docID, IntWritable length, LongWritable hash, Text lang, Text license, Text noBoilerplate, Text html)
    {
        this.docID = new Text(docID);
        this.docLength = new IntWritable(length.get());
        this.docSimHash = new LongWritable(hash.get());
        this.language = new Text(lang);
        this.license = new Text(license);
        this.noBoilerplate = new Text(noBoilerplate);
        this.minimalHtml = new Text();
    }

    public DocumentInfo(DocumentInfo doc) {
        this(doc.getDocID(), doc.getDocLength(), doc.getDocSimHash(), doc.getDocLang(), doc.getLicense(),
                doc.getNoBoilerPlate(), doc.getMinimalHtml());
    }

    /**
     * Constructor to deserialize info from the string produced by toString();
     * 
     * @param descriptorString string as generated by toString()
     */
    public DocumentInfo(String descriptorString) {
        this();
        createDocumentInfo(descriptorString);
    }

    private void createDocumentInfo(String commaSeparatedInfo) {
        // Bracket removal is for when we get the contents of a list without the array notation removed
        String[] pieces = commaSeparatedInfo.replace("[", "").replace("]", "").split(";");

        String docID = pieces[0].trim();
        this.docID = new Text(docID);

        int docLength = Integer.valueOf(pieces[1].trim());
        this.docLength = new IntWritable(docLength);

        long docSimHash = Long.valueOf(pieces[2].trim());
        this.docSimHash = new LongWritable(docSimHash);

        String lang = pieces[3].trim();
        this.language = new Text(lang);

        if (pieces.length > 4) { // New style with more pieces
            this.license = new Text(pieces[4].trim());
            this.noBoilerplate = new Text(pieces[5].trim());
            this.minimalHtml = new Text(pieces[6].trim());
        }
    }

    public Text getDocID() {
        return docID;
    }

    public IntWritable getDocLength() {
        return docLength;
    }

    public LongWritable getDocSimHash() {
        return docSimHash;
    }

    public Text getDocLang() {
        return language;
    }

    public Text getLicense() {
        return this.license;
    }

    public Text getNoBoilerPlate() {
        return this.noBoilerplate;
    }

    public Text getMinimalHtml() {
        return this.minimalHtml;
    }

    @Override
    public void write(DataOutput d)
            throws IOException {
        docID.write(d);
        docLength.write(d);
        docSimHash.write(d);
        language.write(d);
        license.write(d);
        noBoilerplate.write(d);
        minimalHtml.write(d);;
    }

    @Override
    public void readFields(DataInput di)
            throws IOException {
        docID.readFields(di);
        docLength.readFields(di);
        docSimHash.readFields(di);
        language.readFields(di);
        license.readFields(di);
        noBoilerplate.readFields(di);
        minimalHtml.readFields(di);
    }

    @Override
    public int compareTo(DocumentInfo o) {
        return this.docID.compareTo(o.getDocID());
    }

    @Override
    public int hashCode() {
        return Math.abs(docID.hashCode()) * 163 + docSimHash.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof DocumentInfo) {
            DocumentInfo di = (DocumentInfo) o;
            // IDs are unique, so we should never get matching IDs where the other values are different
            return docID.equals(di.getDocID());
        }
        return false;
    }

    @Override
    public String toString() {
        return String.join(";", this.docID.toString(), this.docLength.toString(), this.docSimHash.toString(),
                this.language.toString(), this.license.toString(), this.noBoilerplate.toString(),
                this.minimalHtml.toString());
    }
}
